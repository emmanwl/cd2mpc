#! /usr/bin/env sh
#@(#) Copyright (c) 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 - E.de.Sars
#@(#) All rights reserved.
#@(#)
#@(#) Redistribution and use in source and binary forms, with or without modification, are permitted
#@(#) provided these redistributions must retain the above copyright, this condition and the following
#@(#) disclaimer.
#@(#)
#@(#) THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED
#@(#) WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
#@(#) FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE
#@(#) FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING
#@(#) PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTER-
#@(#) -RUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
#@(#) OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
#@(#) EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#@(#)
#@(#) This is the makefile configuration script for the cd2mpc distribution.
CONFIGURE_VERSION=1.0

E_SUCCESS=0
E_FAILURE=1
E_EXIT=2

# Bootstrap shell
__bootstrap() {
    local target="${TMPDIR:-/tmp}/${1}"
    if [ ! -e "$1" ]; then
       printf "Bootstrap failed: could not find ${1}, exiting.\n" >&2
       return ${E_FAILURE}
    fi
    perl -pe "s#<__(.*?)__>#.#g" "$1" > ${target}.$$
    . ${target}.$$
    rm -f ${target}.$$
}

__bootstrap "libopt4shell.sh" || exit ${E_FAILURE}

# Shell name
__shell="$(__get_calling_shell_name "$0")"
# **
# * Extract configure body line number.
# * @print the line number, in the present file, of the line preceding the script payload
# */
__extract_configure_line_number_minus_one() {
    sed -n "/[[:space:]]*__configure[[:space:]]\{1,\}[^(]/=" ${0} 2>/dev/null | awk 'END {print (NR==1) ? $NF - 1 : "$"}'
}
# **
# * Implementation for the type interface.
# * @param ${1} the candidate string to check
# */
is_string() { __is_of_match "$1" "[[:print:]]+"; }
is_path() { __is_path "$1"; }
# Define options set.
__options_set() {
    local options="I:install-dir:1@path:Specify the install directory <install-dir>
                   m:man-page-dir:1@path:Specify the man page directory <man-page-dir> where to copy man pages
                   r:resources-dir:1@real-path:Specify the directory where to look for *.sh and *rc files
                   s:search-replace:1@key-value:Specify a search/replacement pattern (<__KEY__> replaced by <VALUE>) within a key/value pair (<KEY>=<VALUE>)
                   D:define@:1@key-value:Specify additively a key/value mapping within a key/values pair (<KEY>=<VALUE1,VALUE2,...>)
                   c:dot-file:1@key-value-path:Install, as a dot-file, the <resources-dir> file whose basename is 'KEY' to the location denoted by 'VALUE'
                   v:version:0:Print version information and exit
                   h:help:0:Print help information and exit"
    printf "%s" "$options"
}
# **
# * Print version information.
# */
__print_version() {
cat <<version >&2

This is ${__shell#\./} v${CONFIGURE_VERSION}, a cli tool that automates test/install/check/document tasks for Shell projects.

The tool aims at testing and installing Shell projects in a centralized way: it parses any collection of
scripts (*.sh) or configuration files (*rc), in the <resources-directory>, which do reference parametrized
paths (<__PATH__>) to be valorized with the user input. It produces, at time of invokation, a makefile whose
goals match those predefined test/install/check/document tasks.

These resources are filtered so patterns like '<__KEY__>' are replaced with values communicated within the
--search-replace KEY=<VALUE> switch. '*rc' resources can be marked as dot-files within the special switch
--dot-file <KEY>=<VALUE> where <KEY> denotes the actual file basename (minus the leading '.') and <VALUE>
the targeted directory path.

Type ${__shell} -h for configuration options.

Example:

Given { script.sh, scriptrc, libscript1.sh, libscript2.sh, libscript1test.sh, script.sh.manpage.gz },
libscriptX.sh being referenced in those resources within the pattern '<__libdir__>/libscriptX.sh',
the command: ${__shell} --resources-dir=. 
                         --search-replace libdir=${HOME}/libscript 
                         --install-dir ${HOME}/bin 
                         --define TEST=libscript1test.sh
                         --define INSTALL=script.sh 
                         --dot-file scriptrc=${HOME} 
                         --man-page-dir ${HOME}/.local/share/man
would generate a makefile from which:

- 'make install' will build the following file tree:
  {
    ~/bin/script.sh
    ~/.scriptrc
    ~/libscript/libscript1.sh
    ~/libscript/libscript2.sh
    ~/.local/share/man/man1/script.sh.manpage.gz
  }

- 'make check' would span a new shell to run shellcheck on script.sh in a best-effort mode

- 'make test' would spawn a new shell to run libscript1test.sh

- 'make doc' would deploy script man page (script.sh.manpage.gz) to the man pages user directory

- 'make clean' would leave the place clean (wiping out temporary files) before removing the makefile itself.

version
}
# **
# * Retrieve the first value associated to the given key.
# * @param ${1} the key to look for
# * @param ${2,} the remaining key/value associations
# * @print the value associated to the key in ${2,}
# * @return ${E_SUCCESS} if the key was found else ${E_FAILURE}
# */
__get_key_value() {
    local key="$(__lowerize "$1")" entry value
    shift
    for entry in ${@}; do
        if [ "$(__lowerize "${entry%%=*}")" = "$key" ]; then
           for value in $(__split_tokens_accordingly "," "${entry#*=}"); do
               echo "$value"
           done
           return ${E_SUCCESS}
        fi
    done
    return ${E_FAILURE}
}
# **
# * Build a search/replace expression to use within source files to replace 
# * each key parameter with its value.
# * @param ${@} the whole argument vector
# * @print the search/replace expression
# */
__source_replace_expression() {
    local entry expression
    for entry in ${@}; do
        if [ ! "${entry##*=*}" ]; then
           if [ "$expression" ]; then
              expression="${expression};s#<__${entry%%=*}__>#${entry#*=}#g"
           else
              expression="s#<__${entry%%=*}__>#${entry#*=}#g"
           fi
        fi
    done
    printf "%s" "$expression"
}
# **
# * Build a search/replace expression to use within test files to replace 
# * each key parameter with its value.
# * @param ${@} the whole argument vector
# * @print the search/replace expression
# */
__test_replace_expression() {
    local entry expression wrkdir="$(__get_key_value "WRKDIR" "$@")"
    for entry in ${@}; do
        if [ ! "${entry##*=*}" ]; then
           if [ "$expression" ]; then
              if [ ! "${entry##*\.*}" ]; then
                 expression="${expression};s#<__${entry%%=*}__>#${wrkdir}/test/${entry##*/\.}#g"
              else
                 expression="${expression};s#<__${entry%%=*}__>#${wrkdir}/test#g"
              fi
           elif [ ! "${entry##*\.*}" ]; then
              expression="s#<__${entry%%=*}__>#${wrkdir}/test/${entry##*/\.}#g"
           else
              expression="s#<__${entry%%=*}__>#${wrkdir}/test#g"
           fi
        fi
    done
    printf "%s" "$expression"
}
# **
# * Retrieve shell/rc filenames in the resource directory.
# * @param ${@} the whole argument vector
# * @param ${1} an option indicating whether to exclude or not test (*test.sh) files in the current lookup
# * @print the filenames matching either the mask *.sh or *rc
# */
__list_files_accordingly() {
    local exclude_tests=false file test match=false
    local resourcesdir="$(__get_key_value "RESOURCES_DIR" "$@")"
    local tests="$(__get_key_value "TEST" "$@")"
    case "$1" in
       --exclude-tests) exclude_tests=true; shift ;;
    esac
    for file in ${resourcesdir}/*.sh ${resourcesdir}/*rc; do
        if [ "$file" != "${resourcesdir}/*.sh" -a "$file" != "${resourcesdir}/*rc" ]; then
           match=false
           for test in ${tests}; do
               if [ "$test" = "$(basename "$file")" ]; then
                  match=true
                  break
               fi
           done
           if ${match}; then
              ${exclude_tests} || echo "$file"
           else
              echo "$file"
           fi
        fi
    done
}
# **
# * Copy resources to the target directory.
# * @param ${@} the whole argument vector
# */
__copy_files() {
    __list_files_accordingly "$@" | xargs -I{} cp {} "$(__get_key_value "TARGETDIR" "$@")"
}
# **
# * Copy source files, excluding tests *test.sh, to the target directory.
# * @param ${@} the whole argument vector
# */
copy_sources() {
    __copy_files --exclude-tests "$@"
}
# **
# * Copy source files, including tests, to the target directory.
# * @param ${@} the whole argument vector
# */
copy_tests() {
    __copy_files "$@"
}
# **
# * Edit in place source files to substitute specified patterns with their corresponding values.
# * @param ${@} the whole argument vector
# */
filter_sources() {
    local wrkdir="$(__get_key_value "WRKDIR" "$@")"
    perl -i -pe "$(__source_replace_expression "$@")" "${wrkdir}/install/"* 2>/dev/null
    local key="$(perl -ne "print if s#.*<__(.*?)__>.*#\1#g" "${wrkdir}/install/"* 2>/dev/null | head -n1)"
    if [ "$key" ]; then
       printf "Configure failed: found at least one unresolved pattern: <__${key}__>; reconfigure with --key-value ${key}=<VALUE>\n" >&2
       return ${E_FAILURE}
    fi
    return ${E_SUCCESS}
}
# **
# * Edit in place test files to substitute specified patterns with their corresponding values.
# * @param ${@} the whole argument vector
# */
filter_tests() {
    local wrkdir="$(__get_key_value "WRKDIR" "$@")"
    perl -i -pe "$(__test_replace_expression "$@")" "${wrkdir}/test/"* 2>/dev/null
    local key="$(perl -ne "print if s#.*<__(.*?)__>.*#\1#g" "${wrkdir}/test/"* 2>/dev/null | head -n1)"
    if [ "$key" ]; then
       printf "Configure failed: found at least one unresolved pattern: <__${key}__>; reconfigure with --key-value ${key}=<VALUE>\n" >&2
       return ${E_FAILURE}
    fi
    return ${E_SUCCESS}
}
# **
# * Build a search expression that looks in *.sh files for <keys> defined in ${@}
# * @param ${@} the whole argument vector
# * @print the search expression to use within GREP
# */
__shell_search_pattern() {
    local expression entry
    for entry in ${@}; do
        case "${entry%%=*}" in
           install_dir|test|install|*rc) ;;
                                      *) if [ ! "$expression" ]; then
                                            expression="<__${entry%%=*}__>"
                                         else
                                            expression="${expression}|<__${entry%%=*}__>"
                                         fi ;;
        esac
    done
    printf "%s" "(/{1,}\w{1,}/)*(${expression})/{1,}(\w{1,}/{1,})*\w{1,}\.sh"
}
# **
# * Build a search expression that looks in *rc files for <keys> defined in ${@}
# * @param ${@} the whole argument vector
# * @print the search expression to use within GREP
# */
__configuration_file_search_pattern() {
   local expression entry
   for entry in ${@}; do
       case "${entry%%=*}" in
          install_dir|test|install) ;;
                               *rc) if [ ! "$expression" ]; then
                                       expression="<__${entry%%=*}__>"
                                    else
                                       expression="${expression}|<__${entry%%=*}__>"
                                    fi ;;
       esac
   done
   printf "%s" "(/{1,}\w{1,}/)*(${expression})"
}
# **
# * Evaluate paths, doing required search/replace patterns operations, before sorting them to uniqueness.
# * @param ${@} the whole argument vector
# * @print the evaluated paths, one per line, sorted to uniqueness
# */
__render_paths() { sed "$(__source_replace_expression "$@");s#/\{2,\}#/#g" | sort -u ; }
# **
# * Build the target directory layout.
# * @param ${@} the whole argument vector
# */
build_layout() {
    local wrkdir="$(__get_key_value "WRKDIR" "$@")" resource install_dir="$(__get_key_value "INSTALL_DIR" "$@")" basename
    #
    {
      grep -whoE "$(__shell_search_pattern "$@")" $(__list_files_accordingly --exclude-tests "$@") 2>/dev/null | __render_paths "$@" | while read resource
      do
          echo -c -m 755 -d "$(dirname ${resource})"
          echo -c -m 644 "${wrkdir}/install/$(basename ${resource})" "$resource"
      done
      for resource in $(__get_key_value "INSTALL" "$@"); do
         echo -c -m 755 -d "$install_dir"
         echo -c -m 755 "${wrkdir}/install/${resource}" "${install_dir}/${resource}"
      done
      #
      grep -whoE "$(__configuration_file_search_pattern "$@")" $(__list_files_accordingly --exclude-tests "$@") 2>/dev/null | __render_paths "$@" | while read resource
      do
          basename=$(basename ${resource})
          echo -c -m 755 -d "$(dirname ${resource})"
          echo -c -m 644 "${wrkdir}/install/${basename#\.}" "$resource"
      done
    } | awk '!commands[$0]++' | xargs -t -n5 install
}
# **
# * Copy man pages in a directory, ~/.local/share/man by default, scanned when such a page is
# * manually invoked, see MANPATH in ~/.profile.
# * @param ${@} the whole argument vector
# */
copy_man_pages() {
    local man_page_dir="$(__get_key_value "MAN_PAGE_DIR" "$@")" profile="${HOME}/.profile"
    local value
    if [ "{$man_page_dir:=${HOME}/.local/share/man}" ]; then
       if grep -wE "MANPATH=:*" "$profile" >/dev/null; then
          perl -i -pe "s#MANPATH=.*#MANPATH=\":${man_page_dir}\"#g" "$profile"
       else
          {
	    echo
            echo "# enrich man page lookup path"
            echo "export MANPATH=\":${man_page_dir}\""
          } >> "$profile"
       fi
       {
         for value in $(__get_key_value "INSTALL" "$@"); do
             if [ -s "${value}.manpage.gz" ]; then
                echo -c -m 755 -d "${man_page_dir}/man1"
                echo -c -m 644 "${value}.manpage.gz" "${man_page_dir}/man1/${value}.1.gz"
             fi
         done
       } | awk '!commands[$0]++' | xargs -t -n5 install
    fi
}
# **
# * Generate in the current directory a makefile configured with user options.
# * @param ${@} the whole argument vector
# * @return 0 if the generated makefile is not empty else a non-zero value
# */
__makefile() {
    local wrkdir="/tmp/target" value resource basename associate
    {
      printf "# Generated by configure version ${CONFIGURE_VERSION}.\n"
      printf "CONFIGURE_ARGS = ${@}\n"
      printf "RESOURCES_DIR = "$(__get_key_value "RESOURCES_DIR" "$@")"\n"
      printf "WRKDIR = ${wrkdir}\n"
      printf "INSTALL_DIR = "$(__get_key_value "INSTALL_DIR" "$@")"\n"
      printf "MAN_PAGE_DIR = "$(__get_key_value "MAN_PAGE_DIR" "$@")"\n"
      printf "INSTALL = /usr/bin/install -c\n"
      printf "\n"
      printf "target:\n"
      printf "\t@rm -rf \$(WRKDIR)\n"
      printf "\t@\$(INSTALL) -d -m 755 \$(WRKDIR)\n"
      printf "\n"
      printf "install_directory: target\n"
      printf "\t@\$(INSTALL) -d -m 755 \$(WRKDIR)/install\n"
      printf "\n"
      printf "test_directory: target\n"
      printf "\t@\$(INSTALL) -d -m 755 \$(WRKDIR)/test\n"
      printf "\n"
      printf "copy_sources: install_directory\n"
      printf "\t@sed -n "2,$(__extract_configure_line_number_minus_one)"p configure > \$(WRKDIR)/copy_sources\n"
      printf "\t@echo copy_sources TARGETDIR=\$(WRKDIR)/install \$(CONFIGURE_ARGS)>> \$(WRKDIR)/copy_sources\n"
      printf "\t@sh \$(WRKDIR)/copy_sources\n"
      printf "\n"
      printf "copy_tests: test_directory\n"
      printf "\t@sed -n "2,$(__extract_configure_line_number_minus_one)"p configure > \$(WRKDIR)/copy_tests\n"
      printf "\t@echo copy_tests TARGETDIR=\$(WRKDIR)/test \$(CONFIGURE_ARGS)>> \$(WRKDIR)/copy_tests\n"
      printf "\t@sh \$(WRKDIR)/copy_tests\n"
      printf "\n"
      printf "copy: copy_sources copy_tests\n"
      printf "\n"
      printf "filter_sources: copy_sources\n"
      printf "\t@sed -n "2,$(__extract_configure_line_number_minus_one)"p configure > \$(WRKDIR)/filter_sources\n"
      printf "\t@echo filter_sources WRKDIR=\$(WRKDIR) \$(CONFIGURE_ARGS)>> \$(WRKDIR)/filter_sources\n"
      printf "\t@sh \$(WRKDIR)/filter_sources\n"
      printf "\n"
      printf "filter_tests: copy_tests\n"
      printf "\t@sed -n "2,$(__extract_configure_line_number_minus_one)"p configure > \$(WRKDIR)/filter_tests\n"
      printf "\t@echo filter_tests WRKDIR=\$(WRKDIR) \$(CONFIGURE_ARGS) >> \$(WRKDIR)/filter_tests\n"
      printf "\t@sh \$(WRKDIR)/filter_tests\n"
      printf "\n"
      printf "filter: filter_sources filter_tests\n"
      printf "\n"
      printf "check: filter_sources\n"
      {
        for value in $(__get_key_value "INSTALL" "$@"); do
            if [ -f "$value" ]; then
               printf "\t@shellcheck -x \$(WRKDIR)/install/${value} || { echo Check: shellcheck exited with a non-zero status when checking ${value}; return 1; }\n"
            fi
        done
      }
      printf "\n"
      printf "test: filter_tests\n"
      {
        for value in $(__get_key_value "TEST" "$@"); do
            if [ -f "$value" ]; then
               printf "\t@sh \$(WRKDIR)/test/${value} || { echo Test: test ${value} failed; return 1; }\n"
            fi
        done
      } | sort -R
      printf "\n"
      printf "doc:\n"
      printf "\t@sed -n "2,$(__extract_configure_line_number_minus_one)"p configure > \$(WRKDIR)/copy_man_pages\n"
      printf "\t@echo copy_man_pages \$(CONFIGURE_ARGS) >> \$(WRKDIR)/copy_man_pages\n"
      printf "\t@sh \$(WRKDIR)/copy_man_pages\n"
      printf "\n"
      printf "install: filter_sources doc\n"
      printf "\t@sed -n "2,$(__extract_configure_line_number_minus_one)"p configure > \$(WRKDIR)/build_layout\n"
      printf "\t@echo build_layout WRKDIR=\$(WRKDIR) \$(CONFIGURE_ARGS) >> \$(WRKDIR)/build_layout\n"
      printf "\t@sh \$(WRKDIR)/build_layout\n"
      printf "\n"
      printf "clean:\n"
      printf "\t@rm -rf makefile \$(WRKDIR)\n"
    } > makefile 2>/dev/null
    test -s makefile 2>/dev/null
}
# **
# * Check whether ${1} denotes an existing filepath.
# * @param ${1} the filepath to check
# * @return 0 if ${1} denotes an existing filepath else a non-zero value
# */
is_real_path() {
    realpath "$1" >/dev/null 2>&1
}
# **
# * Parse command line arguments.
# * @print a vector holding user configured options
# */
__parse_options() {
    local argv
    while __argp_parse /options="$(__options_set)" /trim-option-arguments-to-uniqueness /callback-option-prefix=_opt /required-options="I,i,r" "$@"
    do
        case "$_opt" in
                    h) __argp_parse_opts_help
                       return ${E_EXIT}                                                       ;;
                    v) __print_version
                       return ${E_EXIT}                                                       ;;
                    r) __accumulate_once "RESOURCES_DIR=$(realpath "$_optarg")" argv          ;;
                    I) __accumulate_once "INSTALL_DIR=${_optarg}" argv                        ;;
                  \@D) __accumulate_once "$_optarg" argv                                      ;;
                    s) __accumulate_once "$_optarg" argv                                      ;;
                    c) __accumulate_once "${_optarg%%=*}=${_optarg#*=}/.${_optarg%%=*}" argv  ;;
                    m) __accumulate_once "MAN_PAGE_DIR=${_optarg}" argv                       ;;
        esac
    done
    printf "%s" "$argv"
}
# **
# * Script payload.
# * @param ${@} the whole argument vector
# * @return ${E_SUCCESS} if called with a terminal option (-h, -v or alternatively --help, --version) or if the makefile was properly generated, else ${E_FAILURE}
# */
__configure () {
    local argv r
    argv="$(__parse_options "$@")"
    if [ ${r:=${?}} -eq ${E_EXIT} ]; then
       return ${E_SUCCESS}
    elif [ ${r} -ne ${E_SUCCESS} ]; then
       return ${E_FAILURE}
    elif ! __makefile "$argv"; then
       printf "Configure failed: could not generate makefile.\n" >&2
       return ${E_FAILURE}
    fi
}

__configure "$@" --resources-dir=. --install-dir ${HOME}/bin --dot-file cd2mpcrc=${HOME} --search-replace libdir=${HOME}/libs4shell --search-replace libtools=${HOME}/libs4shell/libtools --define TEST=libopt4test.sh --define INSTALL=cd2mpc.sh --man-page-dir ${HOME}/.local/share/man
